---
title: æ’åºæ•°ç»„-LeetCode
categories: ä½œä¸šç»ƒä¹ 
tags:
  - LeetCode
æ•°æ®ç»“æ„:
  - æ•°ç»„
  - å¸Œå°”æ’åº
  - æ’åº
  - å½’å¹¶æ’åº
date: 2025-12-13
---
# æ’åºæ•°ç»„

## ğŸ¯ é—®é¢˜æè¿°ï¼ˆæ¥æºäºLeetCodeï¼‰
**æè¿°**ï¼š
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums`ï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚
ä½ å¿…é¡»åœ¨Â **ä¸ä½¿ç”¨ä»»ä½•å†…ç½®å‡½æ•°**Â çš„æƒ…å†µä¸‹è§£å†³é—®é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºÂ `O(nlog(n))`ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦å°½å¯èƒ½å°ã€‚
**è¯´æ˜**ï¼š

- `1 <= nums.length <= 5 * 104`
- `-5 * 104 <= nums[i] <= 5 * 104`

**ç¤ºä¾‹**ï¼š

- ç¤ºä¾‹ 1ï¼š

```text
è¾“å…¥ï¼šnums = [5,2,3,1]
è¾“å‡ºï¼š[1,2,3,5]
è§£é‡Šï¼šæ•°ç»„æ’åºåï¼ŒæŸäº›æ•°å­—çš„ä½ç½®æ²¡æœ‰æ”¹å˜ï¼ˆä¾‹å¦‚ï¼Œ2 å’Œ 3ï¼‰ï¼Œè€Œå…¶ä»–æ•°å­—çš„ä½ç½®å‘ç”Ÿäº†æ”¹å˜ï¼ˆä¾‹å¦‚ï¼Œ1 å’Œ 5ï¼‰ã€‚
```

- ç¤ºä¾‹ 2ï¼š

```text
è¾“å…¥ï¼šnums = [5,1,1,2,0,0]
è¾“å‡ºï¼š[0,0,1,1,2,5]
è§£é‡Šï¼šè¯·æ³¨æ„ï¼Œnums çš„å€¼ä¸ä¸€å®šå”¯ä¸€ã€‚
```
## ğŸ’» è§£é¢˜æ€è·¯
### æ€è·¯1ï¼šå¸Œå°”æ’åº
#### æ€è·¯1ï¼šä»£ç å®ç°
```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        size=len(nums)
        gap=size // 2
        while gap>0:
            for i in range(gap,size):
                temp=nums[i]
                j=i
                while j>=gap and nums[j-gap]>temp:
                    nums[j]=nums[j-gap]
                    j-=gap
                nums[j]=temp
            gap//=2
        return nums
```
#### æ€è·¯1ï¼šğŸ“Š æ€§èƒ½åˆ†æ
##### æäº¤ç»“æœ
- **è¿è¡Œæ—¶é—´**ï¼š635mså‡»è´¥39.21%
- **å†…å­˜æ¶ˆè€—**ï¼š23.51MBå‡»è´¥92.42%
##### å¤æ‚åº¦éªŒè¯
- æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$
### æ€è·¯2ï¼šå½’å¹¶æ’åº
#### æ€è·¯2ï¼šä»£ç å®ç°
```python
class Solution:
    def merge(self,left_nums:[int],right_nums:[int]):
        nums=[]
        left_i=right_i=0
        while left_i<len(left_nums)and right_i<len(right_nums):
            if left_nums[left_i]<right_nums[right_i]:
                nums.append(left_nums[left_i])
                left_i+=1
            else:
                nums.append(right_nums[right_i])
                right_i+=1
        while left_i<len(left_nums):
            nums.append(left_nums[left_i])
            left_i+=1
        while right_i<len(right_nums):
            nums.append(right_nums[right_i])
            right_i+=1
        return nums
    def mergesort(self,nums:[int])->[int]:
        if len(nums)<=1:
            return nums
        mid=len(nums)//2
        left_nums=self.mergesort(nums[0:mid])
        right_nums=self.mergesort(nums[mid:])
        return self.merge(left_nums,right_nums)
    def sortArray(self, nums: List[int]) -> List[int]:
        return self.mergesort(nums)

        return nums
```
#### æ€è·¯2ï¼šğŸ“Š æ€§èƒ½åˆ†æ
##### æäº¤ç»“æœ
- **è¿è¡Œæ—¶é—´**ï¼š771mså‡»è´¥19.44%
- **å†…å­˜æ¶ˆè€—**ï¼š25.03MBå‡»è´¥43.20%
##### å¤æ‚åº¦éªŒè¯
- æ—¶é—´å¤æ‚åº¦ï¼š$O(Nlogn)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$
### æ€è·¯3ï¼šå¿«é€Ÿæ’åº
#### æ€è·¯3ï¼šä»£ç å®ç°
```python
import random
class Solution:
Â  Â  def randomPartition(self,nums:[int],low:int,high:int)->int:
Â  Â  Â  Â  i=random.randint(low,high)
Â  Â  Â  Â  nums[low],nums[i]=nums[i],nums[low]
Â  Â  Â  Â  return self.partition(nums,low,high)
Â  Â  def partition(self,nums:[int],low:int,high:int)->int:
Â  Â  Â  Â  pivot=nums[low]
Â  Â  Â  Â  i,j=low,high
Â  Â  Â  Â  while i<j:
Â  Â  Â  Â  Â  Â  while i<j and nums[j]>=pivot:
Â  Â  Â  Â  Â  Â  Â  Â  j-=1
Â  Â  Â  Â  Â  Â  while i<j and nums[i]<=pivot:
Â  Â  Â  Â  Â  Â  Â  Â  i+=1
Â  Â  Â  Â  Â  Â  nums[i],nums[j]=nums[j],nums[i]
Â  Â  Â  Â  nums[low],nums[j]=nums[j],nums[low]
Â  Â  Â  Â  return i
Â  Â  def quicksort(self,nums:[int],low:int,high:int)->[int]:
Â  Â  Â  Â  if low <high:
Â  Â  Â  Â  Â  Â  pivot_i=self.randomPartition(nums,low,high)
Â  Â  Â  Â  Â  Â  self.quicksort(nums,low,pivot_i-1)
Â  Â  Â  Â  Â  Â  self.quicksort(nums,pivot_i+1,high)
Â  Â  Â  Â  return nums
Â  Â  def sortArray(self, nums: List[int]) -> List[int]:
Â  Â  Â  Â  return self.quicksort(nums,0,len(nums)-1)
```
#### æ€è·¯3ï¼šğŸ“Š æ€§èƒ½åˆ†æ
##### æäº¤ç»“æœ
- **è¿è¡Œæ—¶é—´**ï¼šè¶…æ—¶
- **å†…å­˜æ¶ˆè€—**ï¼š
##### å¤æ‚åº¦éªŒè¯
- æ—¶é—´å¤æ‚åº¦ï¼š$O(Nlogn)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$
