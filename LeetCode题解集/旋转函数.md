---
title: 旋转函数-LeetCode
categories: 作业练习
tags:
  - LeetCode
数据结构:
  - 数组
date: 2025-12-10
---
# 旋转函数

## 🎯 问题描述（来源于LeetCode）
**描述**：
给定一个长度为 `n` 的整数数组 `nums` 。
假设 `arrk` 是数组 `nums` 顺时针旋转 `k` 个位置后的数组，我们定义 `nums` 的 **旋转函数**  `F` 为：
- `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`
**要求**：
返回 _`F(0), F(1), ..., F(n-1)`中的最大值_ 。
生成的测试用例让答案符合 **32 位** 整数。
**说明**：
- `n == nums.length`
- `1 <= n <= 105`
- `-100 <= nums[i] <= 100`
**示例**：

- 示例 1：
**输入:** nums = [4,3,2,6]
**输出:** 26
**解释:**
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。

- 示例 2：
**输入:** nums = [100]
**输出:** 0
## 💻 解题思路
### 思路1：遍历
#### 思路1：代码实现
```python
class Solution:
    def maxRotateFunction(self, nums: List[int]) -> int:
        F = float('-inf')
        sum1=0
        n=len(nums)
        for i in range(n):
            for j in range(n):
                d=(i+j)%n
                sum1+=j*nums[d]
            if F<sum1:
                F=sum1
            sum1=0
        return F
```
#### 思路1：📊 性能分析
##### 提交结果
- **运行时间**：超出时间限制
- **内存消耗**：
##### 复杂度验证
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
#### 思考
虽然观察到函数规律但由于双重for循环的遍历导致时间复杂度过大
### 思路1：观察递归公式
#### 思路1：代码实现
```python
class Solution:
    def maxRotateFunction(self, nums: List[int]) -> int:
        """
        F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
        F(k+1)=0*arrk[n-1]+1*arrk[2]+...+(n-2)*arrk[n-2]
        F(K+1)-F(K)=sum(arrk[0:n])-n*arrk[n-k]
        """
        sum1=0
        F=0
        sum2=0
        n=len(nums)
        for i in range(n):
            sum1+=nums[i]
            F+=i*nums[i]
        a=F
        for i in range(1,n):
            d=n*nums[n-i]
            sum2=a+sum1-d
            a=sum2
            if sum2>F:
                F=sum2
        return F
```
#### 思路2：📊 性能分析
##### 提交结果
- **运行时间**：127ms击败90.18%
- **内存消耗**：25.38MB击败31.29%
##### 复杂度验证
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
#### 思考
找到递推公式就可以一次遍历了