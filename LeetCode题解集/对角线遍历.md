---
title: å¯¹è§’çº¿éå†-LeetCode
categories: ä½œä¸šç»ƒä¹ 
tags:
  - LeetCode
æ•°æ®ç»“æ„:
  - æ•°ç»„
date: 2025-12-13
---
# å¯¹è§’çº¿éå†

## ğŸ¯ é—®é¢˜æè¿°ï¼ˆæ¥æºäºLeetCodeï¼‰
**æè¿°**ï¼š
ç»™ä½ ä¸€ä¸ªå¤§å°ä¸ºÂ `m x n`Â çš„çŸ©é˜µÂ `mat`Â ï¼Œè¯·ä»¥å¯¹è§’çº¿éå†çš„é¡ºåºï¼Œç”¨ä¸€ä¸ªæ•°ç»„è¿”å›è¿™ä¸ªçŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
**è¯´æ˜**ï¼š
- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 104`
- `1 <= m * n <= 104`
- `-105 <= mat[i][j] <= 105`
**ç¤ºä¾‹**ï¼š

- ç¤ºä¾‹ 1ï¼š

```text
è¾“å…¥ï¼šmat = [[1,2,3],[4,5,6],[7,8,9]]
è¾“å‡ºï¼š[1,2,4,7,5,3,6,8,9]
```

- ç¤ºä¾‹ 2ï¼š

```text
è¾“å…¥ï¼šmat = [[1,2],[3,4]]
è¾“å‡ºï¼š[1,2,3,4]
```
## ğŸ’» è§£é¢˜æ€è·¯
### æ€è·¯1ï¼šéå†
#### æ€è·¯1ï¼šä»£ç å®ç°
```python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        if not mat or not mat[0]:
            return []
        m, n = len(mat), len(mat[0])
        ans = []
        row, col = 0, 0
        direction = 1  
        while len(ans) < m * n:
            ans.append(mat[row][col])
            if direction == 1:  
                new_row = row - 1
                new_col = col + 1
            else:  
                new_row = row + 1
                new_col = col - 1
            is_out_of_bounds = new_row < 0 or new_row >= m or new_col < 0 or new_col >= n
            if not is_out_of_bounds:
                row, col = new_row, new_col
            else:
                if direction == 1: 
                    if col + 1 < n:
                        col += 1
                    else:
                        row += 1
                else:  
                    if row + 1 < m:
                        row += 1
                    else:
                        col += 1
                direction *= -1
        return ans
```
#### æ€è·¯1ï¼šğŸ“Š æ€§èƒ½åˆ†æ
##### æäº¤ç»“æœ
- **è¿è¡Œæ—¶é—´**ï¼š13mså‡»è´¥50.65%
- **å†…å­˜æ¶ˆè€—**ï¼š19.50MBå‡»è´¥25.22%
##### å¤æ‚åº¦éªŒè¯
- æ—¶é—´å¤æ‚åº¦ï¼š$O(m*n)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(m*n)$
#### æ€è€ƒ
è®°å½•éå†æ–¹å‘ï¼Œè¶Šç•Œåè½¬