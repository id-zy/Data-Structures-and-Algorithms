---
title: 数组的相对排序-LeetCode
categories: 作业练习
tags:
  - LeetCode
数据结构:
  - 计数排序
  - 数组
date: 2026-01-21
---
# 数组的相对排序

## 🎯 问题描述（来源于LeetCode）
**描述**：
给你两个数组，`arr1` 和 `arr2`，`arr2` 中的元素各不相同，`arr2` 中的每个元素都出现在 `arr1` 中。
对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。
**说明**：
- `1 <= arr1.length, arr2.length <= 1000`
- `0 <= arr1[i], arr2[i] <= 1000`
- `arr2` 中的元素 `arr2[i]`  **各不相同** 
- `arr2` 中的每个元素 `arr2[i]` 都出现在 `arr1` 中
**示例**：

- 示例 1：

```text
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
```

- 示例 2：

```text
输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
```
## 💻 解题思路
### 思路1：计数排序
#### 思路1：代码实现
```python
class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        mi, ma = min(arr1), max(arr1)
        size = ma - mi + 1
        counts = [0 for _ in range(size)]
        for num in arr1:
            counts[num - mi] += 1
        res = []
        for num in arr2:
            if counts[num - mi] > 0:
                res.extend([num] * counts[num - mi])
                counts[num - mi] = 0  
        for i in range(size):
            if counts[i] > 0:
                res.extend([i + mi] * counts[i])
        return res
```
#### 思路1：📊 性能分析
##### 提交结果
- **运行时间**：0ms击败100.00%
- **内存消耗**：19.26MB击败5.07%
##### 复杂度验证
- 时间复杂度：$O(N+M)$
- 空间复杂度：$O(N)$
#### 思考
