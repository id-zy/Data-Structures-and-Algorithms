
## **1. 问题定义**
- 有 $n$ 个物品，每个物品重量为 $w_i$，价值为 $v_i$（$1 \leq i \leq n$）。
- 背包容量为 $C$。
- 目标：选择物品放入背包，使总重量不超过 $C$，且总价值最大。
- 每个物品只能选或不选（0或1）。

---

## **2. 动态规划状态定义**
定义二维数组 $dp[i][j]$，表示考虑前 $i$ 个物品，背包容量为 $j$ 时的最大价值。

- $i$：考虑前 $i$ 个物品（$0 \leq i \leq n$）。
- $j$：当前背包容量（$0 \leq j \leq C$）。

---

## **3. 状态转移方程**
对于第 $i$ 个物品（注意：物品下标从1开始）：
- **不选**第 $i$ 个物品：  
  $dp[i][j] = dp[i-1][j]$。
- **选**第 $i$ 个物品（前提：$j \geq w_i$）：  
  $dp[i][j] = dp[i-1][j-w_i] + v_i$。

取两者最大值：
$$
dp[i][j] = 
\begin{cases}
\max(dp[i-1][j], \ dp[i-1][j-w_i] + v_i) & \text{if } j \geq w_i \\
dp[i-1][j] & \text{if } j < w_i
\end{cases}
$$

---

## **4. 初始化**
- $dp[0][j] = 0$（没有物品，价值为0）。
- $dp[i][0] = 0$（容量为0，无法放任何物品）。

实际上，我们可以将整个 $dp$ 数组初始化为0。

---

## **5. 计算顺序**
按 $i$ 从 $1$ 到 $n$，$j$ 从 $1$ 到 $C$ 递推计算。

---

## **6. 空间优化（滚动数组）**
由于 $dp[i][j]$ 只依赖于 $dp[i-1][\cdot]$，可以使用一维数组 $dp[j]$（$0 \leq j \leq C$）进行**逆序更新**：
- 初始化 $dp[j] = 0$。
- 对于每个物品 $i$，从 $j = C$ 到 $w_i$ 逆序更新：
  $$
  dp[j] = \max(dp[j], \ dp[j-w_i] + v_i)
 $$
**注意**：逆序是为了保证每个物品只被考虑一次（0-1背包性质）。如果是完全背包（物品无限），则需要正序更新。

---

## **7. 算法复杂度**
- 时间复杂度：$O(n \times C)$。
- 空间复杂度（优化后）：$O(C)$。

---

## **8. 示例**
设 $n=3, C=4$，物品如下：

| 物品 | 重量 $w_i$ | 价值 $v_i$ |
|------|-------------|-------------|
| 1    | 2           | 4           |
| 2    | 1           | 2           |
| 3    | 3           | 3           |

**计算过程（二维表）**：

| $i \backslash j$ | 0   | 1   | 2   | 3   | 4   |
| ---------------- | --- | --- | --- | --- | --- |
| 0                | 0   | 0   | 0   | 0   | 0   |
| 1                | 0   | 0   | 4   | 4   | 4   |
| 2                | 0   | 2   | 4   | 6   | 6   |
| 3                | 0   | 2   | 4   | 6   | 6   |

最大价值为 $dp[3][4] = 6$。

---

## **9. 构造最优解（选了哪些物品）**
如需输出具体方案，可以在二维动态规划表中**回溯**：
- 从 $i=n, j=C$ 开始。
- 如果 $dp[i][j] == dp[i-1][j]$，说明第 $i$ 个物品未选，则 $i = i-1$。
- 否则，第 $i$ 个物品被选，记录 $i$，并令 $j = j - w_i$，$i = i-1$。
- 重复直到 $i=0$。

对于一维数组优化版本，需要额外记录选择信息（如用二维布尔数组或通过比较前后状态判断）。

---

## **10. 代码实现（Python）**
```python
def knapsack_01(n, C, w, v):
    dp = [0] * (C + 1)
    for i in range(n):
        for j in range(C, w[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - w[i]] + v[i])
    return dp[C]

# 示例
n = 3
C = 4
w = [2, 1, 3]
v = [4, 2, 3]
print(knapsack_01(n, C, w, v))  # 输出 6
```
